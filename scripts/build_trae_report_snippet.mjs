import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';

const args = process.argv.slice(2);
const taskIdArg = args.find(arg => arg.startsWith('--task_id='));
const resultDirArg = args.find(arg => arg.startsWith('--result_dir='));

if (!taskIdArg || !resultDirArg) {
    console.error('Usage: node scripts/build_trae_report_snippet.mjs --task_id=<id> --result_dir=<dir>');
    process.exit(1);
}

const taskId = taskIdArg.split('=')[1];
const resultDir = resultDirArg.split('=')[1];

console.log(`[Snippet Builder] Building report snippet for task ${taskId}...`);

// 1. Get Git Info
let branchName = 'unknown';
let commitHash = 'unknown';
let scopeDiff = '';

try {
    // Fail-fast fetch to ensure we have origin/main
    try {
        execSync('git fetch origin main', { stdio: 'inherit' });
    } catch (e) {
        console.warn('[Snippet Builder] WARNING: Could not fetch origin main. Using local cache if available.');
    }

    branchName = execSync('git rev-parse --abbrev-ref HEAD').toString().trim();
    commitHash = execSync('git rev-parse --short HEAD').toString().trim();
    
    try {
        scopeDiff = execSync('git diff --name-status origin/main...HEAD').toString().trim();
    } catch (e) {
        scopeDiff = ''; 
    }

    if (!scopeDiff) {
        scopeDiff = 'EMPTY_DIFF_OK\nReason: No code changes detected against origin/main (Evidence/Docs update only)';
    }
} catch (e) {
    console.warn('[Snippet Builder] Git command failed:', e.message);
    scopeDiff = '(Git diff failed or not a git repo)';
}

// 2. Read DoD Stdout (from notify file is safer/source of truth, or dod_stdout file)
// Requirement says: "=== DOD_EVIDENCE_STDOUT ===（从 notify 中提取即可）"
const notifyPath = path.join(resultDir, `notify_${taskId}.txt`);
let dodContent = '(Missing DoD Evidence)';

if (fs.existsSync(notifyPath)) {
    const notifyContent = fs.readFileSync(notifyPath, 'utf8');
    const marker = '=== DOD_EVIDENCE_STDOUT ===';
    if (notifyContent.includes(marker)) {
        // Extract from marker to end or next marker? 
        // Usually DoD block is at the end or followed by snippet ref.
        // Let's assume it's the block starting with marker.
        const parts = notifyContent.split(marker);
        if (parts.length > 1) {
            // Take the part after the marker. 
            // We need to stop before TRAE_REPORT_SNIPPET or end of file.
            let content = parts[1];
            // If there are other sections, we might need to be careful. 
            // But DoD is usually injected last before snippet.
            // Let's just take the lines that look like DoD lines + the marker.
            
            // Actually, simpler: Read dod_stdout file if available, else extract.
            // The previous script read dod_stdout_<taskid>.txt. Let's stick to that if it exists, 
            // as it's the "clean" source generated by dev_batch_mode.
            const dodStdoutPath = path.join(resultDir, `dod_stdout_${taskId}.txt`);
            if (fs.existsSync(dodStdoutPath)) {
                 dodContent = fs.readFileSync(dodStdoutPath, 'utf8').trim();
            } else {
                 // Fallback to notify extraction
                 dodContent = marker + '\n' + parts[1].trim();
            }
        }
    }
}

// 2.5. CI Parity Probe (Task 260210_009+)
let ciParityContent = '';
if (taskId >= '260210_009') {
    const probeFile = path.join(resultDir, `ci_parity_${taskId}.txt`);
    if (fs.existsSync(probeFile)) {
        const content = fs.readFileSync(probeFile, 'utf8');
        const marker = '=== CI_PARITY_PREVIEW ===';
        if (content.includes(marker)) {
            const parts = content.split(marker);
            ciParityContent = marker + parts[1]; // Include everything after marker
        }
    } else {
        console.warn(`[Snippet Builder] Warning: CI Parity Probe file missing: ${probeFile}`);
    }
}

// 3. Construct Snippet Content
// Requirement:
// BRANCH / COMMIT
// === DOD_EVIDENCE_STDOUT ===
// === CI_PARITY_PREVIEW === (If applicable)
// === GATE_LIGHT_PREVIEW === (Placeholder)
// GATE_LIGHT_EXIT=<code> (Placeholder)

const snippetContent = `
=== TRAE_REPORT_SNIPPET ===

BRANCH: ${branchName}
COMMIT: ${commitHash}

=== GIT_SCOPE_DIFF ===
${scopeDiff || '(No changes detected or new branch)'}

${dodContent}

${ciParityContent}

=== GATE_LIGHT_PREVIEW ===
(Pending Gate Light Execution...)
[Gate Light] STATUS_PENDING

GATE_LIGHT_EXIT=__PENDING__
`;

const snippetPath = path.join(resultDir, `trae_report_snippet_${taskId}.txt`);
fs.writeFileSync(snippetPath, snippetContent.trim() + '\n');
console.log(`[Snippet Builder] Wrote snippet to: ${snippetPath}`);
console.log(`[Snippet Builder] NOTE: Notify/Result/Index updates must be handled by the caller (dev_batch_mode).`);
